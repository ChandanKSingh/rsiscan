/* Programmer:	Daga <daga@epicvoyage.org>
 * Started:	June 19, 2007
 *
 * Compile:	$ cc -o rsiscan rsiscan.c
 *
 * Sample run:	$ ./rsiscan GOOG YHOO AMD INTC
 * 		70.21 > 70: INTC
 *
 * It is probably best to run this 6-7 hours (or more)
 * after the market closes in order to have that day's
 * closing values.
 *
 * Released under the terms of the GNU GPL v2, and
 * I'd be interested in seeing what you base off of
 * this.
 */

#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <netdb.h>
#include <errno.h>
#include <time.h>

/* "Custom" data types */
typedef enum {yahoo = 0, google = 2, invest = 4} server;
typedef enum {false = 0, true = 1} bool;

/* Servers to query for CSV data */
const char *servers[] = { "ichart.finance.yahoo.com", "download.finance.yahoo.com",
			  "finance.google.com", "",
			  "dunno", ""
			};

/* 1.1 - Basic program functionality */
void create_config();
void create_dir(char *path);
void read_args(int argc, char **argv);
void print_help(char *prog);
void cleanup();

/* 1.2 - Get/Save/Read stock data (cache) */
void save_to_file(char *ticker, void ***data, long rows, long cols);
char *load_from_file(char *ticker);
char *download_eod_data(char *ticker, time_t from);
void send_request(FILE *out, char *ticker, time_t from);
char *retrieve_data(FILE *in);
void ***parse_csv(char *block, long *rows, long *cols);
void recursive_free(void ***data, long rows);

/* 1.3 - Run modes */
void update_tickers();
void load_ticker(char *ticker);
void up_percent(char *percent);

/* 1.4 - Functions which extrapolate from data */
time_t get_last_date(void ***data, long rows);
long average_volume(void ***data, long rows);
double generate_rsi(void ***data, long rows, int n);
void ***make_weekly(void ***data, long rows, long *w_rows, long *w_cols);
void print_analysis(char *ticker, double rsi, double weekly);

/* Global variables */
bool save_config, intraday;
char *config_dir;
server source;

/*****************************
 * 1.0 - Program entry point 
 *****************************/
int main(int argc, char **argv)
{
	config_dir = NULL;
	skip_today = false;

	create_config();
	read_args(argc, argv);

	cleanup();

	return 0;
}

/*************************************************
 * 1.1 - Basic program functionality
 *************************************************
 * Create save directory for downloaded CSV data */
void create_config()
{
	char *home;

	save_config = true;

	home = getenv("HOME");
	create_dir(home);

	config_dir = (char *)malloc(strlen(home) + 20);
	sprintf(config_dir, "%s/.daga", home);
	create_dir(config_dir);

	sprintf(config_dir, "%s/.daga/rsiscan", home);
	create_dir(config_dir);

	sprintf(config_dir, "%s/.daga/rsiscan/data", home);
	create_dir(config_dir);

	return;
}

/* Attempt to create a directory. If we fail, don't try to save data */
void create_dir(char *path)
{
	struct stat buf;

	if ((save_config) && (stat(path, &buf)))
	{
		if (mkdir(path, S_IRWXU))
		{
			fprintf(stderr, "Error creating directory: %s\n", path);
			save_config = false;
		}
	}

	return;
}

/* Parse command line options */
void read_args(int argc, char **argv)
{
	int x;

	/* This will allow different sources to be used for different stocks
	 * ("hidden feature" :) */
	source = yahoo;

	for (x = 1; x < argc; x++)
	{
		if (strcmp(argv[x], "--yahoo") == 0)
			source = yahoo;
		else if (strcmp(argv[x], "--google") == 0)
			source = google;
		/*else if (strcmp(argv[x], "--invest") == 0)
			source = invest;*/
		else if (strcmp(argv[x], "--update") == 0)
			update_tickers();
		else if ((strncmp(argv[x], "--up", 4) == 0) && (strlen(argv[x]) > 4))
			up_percent(argv[x] + 4);
		else if (*argv[x] != '-')
			load_ticker(argv[x]);
		else
			print_help(argv[0]);
	}

	if (argc == 1)
		update_tickers();

	return;
}


/* Print program usage and exit */
void print_help(char *prog)
{
	printf("Usage: %s [--switch] [TKR1] [TKR2] [TKR3] [etc.]\n\n", prog);

	printf("    --yahoo     Download data from finance.yahoo.com [default]\n");
	printf("    --google    Download data from finance.google.com\n");
	/*printf("    --invest    Download data from InvestorLink [commercial]\n");*/
	printf("    --update    Update all of the stocks previously downloaded [default]\n");
	printf("    --up##      Show stocks that have moved up ## percent\n");
	printf("    --help      Print this text and exit\n\n");

	printf("We automatically filter out stocks with an average trading volume under one\n");
	printf("million shares per day over the past two weeks.\n\n");

	printf("This program will perform an analysis on the stocks you specify. It is *NOT*\n");
	printf("advice and should not be used in place of actual advice from a stock broker.\n");
	printf("It simply tries to look for anamolies in large amounts of data, but is not\n");
	printf("guaranteed to even do that. Use at your own risk.\n\n");

	cleanup();
	exit(0);
}

/* Free allocated global memory */
void cleanup()
{
	if (config_dir != NULL)
		free(config_dir);

	return;
}

/***************************************************
 * 1.2 - Get/Save/Read stock data (cache)
 ***************************************************
 * Save (cache) ticker data to files for later use */
void save_to_file(char *ticker, void ***data, long rows, long cols)
{
	char *filename, *tkr, *tmp;
	long x, y;
	FILE *wr;

	if (!save_config)
		return;

	tkr = (char *)malloc(strlen(ticker) + 1);
	strcpy(tkr, ticker);
	tmp = tkr;
	while (*tmp = tolower(*tmp++));

	filename = (char *)malloc(strlen(config_dir) + strlen(tkr) + 6);
	sprintf(filename, "%s/%s.csv", config_dir, tkr);

	wr = fopen(filename, "w");
	for (x = 1; x <= rows; x++)
	{
		if (data[x][0])
		{
			for (y = 1; y < cols; y++)
				fprintf(wr, "%s,", data[x][y]);
			fprintf(wr, "%s\n", data[x][y]);
		}
	}
	fclose(wr);

	free(filename);
	free(tkr);

	return;
}

/* Load ticker data from files */
char *load_from_file(char *ticker)
{
	char *filename, *tkr, *tmp, *ret = NULL;
	struct stat buf;
	long x, y;
	FILE *re;

	if (!save_config)
		return NULL;

	tkr = (char *)malloc(strlen(ticker) + 1);
	strcpy(tkr, ticker);
	tmp = tkr;
	while (*tmp = tolower(*tmp++));
	tmp = NULL;

	filename = (char *)malloc(strlen(config_dir) + strlen(tkr) + 6);
	sprintf(filename, "%s/%s.csv", config_dir, tkr);

	if (stat(filename, &buf))
		return NULL;

	re = fopen(filename, "r");
	tmp = (char *)malloc(2048);
	while (fgets(tmp, 2048, re) != NULL)
	{
		if (ret == NULL)
		{
			ret = (char *)malloc(strlen(tmp) + 1);
			*ret = '\0';
		}
		else
			ret = (char *)realloc(ret, strlen(ret) + strlen(tmp) + 1);

		strcat(ret, tmp);
	}

	fclose(re);
	free(filename);
	free(tkr);
	free(tmp);

	return ret;
}

/* Download ticker data */
char *download_eod_data(char *ticker, time_t from)
{
	struct hostent *record;
	struct sockaddr_in sin;
	char *ptr, *ret = NULL;
	int sock, conn;
	FILE *wr, *re;

	if ((record = gethostbyname(servers[source + intraday])) == NULL)
	{
		fprintf(stderr, "DNS lookup for %s failed!\n", servers[source + intraday]);
		cleanup();
		exit(1);
	}

	sin.sin_family = AF_INET;
	sin.sin_port = htons(80);
	sin.sin_addr.s_addr = inet_addr(inet_ntoa(*(struct in_addr*)record->h_addr));

	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
	{
		fprintf(stderr, "Failed to open a socket!\n");
		cleanup();
		exit(1);
	}

	if ((conn = connect(sock, (struct sockaddr *)&sin, sizeof(sin))) < 0)
	{
		fprintf(stderr, "Error connecting to %s: %s\n", servers[source + intraday], strerror(errno));
		return NULL;
	}

	wr = fdopen(sock, "w");
	re = fdopen(sock, "r");

	send_request(wr, ticker, from);
	ret = retrieve_data(re);

	if (strcasestr(ret, "Sorry, the page you requested was not found."))
	{
		printf("Error: %s - No data found\n", ticker);
		free(ret);
		ret = NULL;
	}

	fclose(wr);
	fclose(re);
	close(sock);

	return ret;
}

/* Send request tailored for the chosen server */
void send_request(FILE *out, char *ticker, time_t from)
{
	struct tm *date_start, date_finish;
	time_t epoch;

	time(&epoch);
	memcpy(&date_finish, localtime(&epoch), sizeof(struct tm));
	epoch = ((from == 0) ? epoch - 31536000 : from + 86400);
	date_start = localtime(&epoch);

	if ((date_start->tm_mday == date_finish.tm_mday) && (date_start->tm_mon  == date_finish.tm_mon) && (date_start->tm_year == date_finish.tm_year))

	if ((source == yahoo) && (!intraday))
		fprintf(out, "GET /table.csv?s=%s&a=%i&b=%i&c=%i&d=%i&e=%i&f=%i&g=d&ignore=.csv HTTP/1.1\r\n", ticker,
			date_start->tm_mon, date_start->tm_mday, date_start->tm_year + 1900,
			date_finish.tm_mon, date_finish.tm_mday, date_finish.tm_year + 1900);
	else if (source == yahoo)
		fprintf(out, "GET /d/quotes.csv?s=%s&f=ohgl1v&e=.csv HTTP/1.1\r\n", ticker);
	else if (source == google)
		fprintf(out, "GET /finance/historical?q=%s&output=csv HTTP/1.1\r\n", ticker);
	fprintf(out, "HOST: %s\r\n\r\n", servers[source]);
	fflush(out);

	return;
}

/* Read back CSV data from server */
char *retrieve_data(FILE *in)
{
	bool chunked = false, start = false;
	long x, len, content = 0;
	char *read, *ret = NULL;

	read = (char *)malloc(2048);
	while (fgets(read, 2048, in) != NULL)
	{
		if (!start)
			chunked = ((char *)strcasestr(read, "Transfer-Encoding: chunked") == NULL);

		if ((!start) && (strncasecmp(read, "Content-Length: ", 16) == 0) && (isdigit(*(read + 16))))
			content = strtol(read + 16, NULL, 10);

		if ((*read == '\r') || (*read == '\n'))
		{
			if ((content) && (ret == NULL))
			{
				ret = (char *)malloc(content + 1);
				if ((x = fread(ret, 1, content, in)) < content)
				{
					*(ret + x + 1) = 0;
					start = true;
				}
				else
				{
					*(ret + x + 1) = 0;
					break;
				}
			}
			else if ((chunked) && (ret == NULL))
			{
				fgets(read, 2048, in);
				start = true;

				/* - Yahoo doesn't seem to give us the right number?
				if (fgets(read, 2048, in) != NULL)
				{
					len = atol(read);
					printf("%s => %li\n", read, len);
					ret = (char *)malloc(len + 1);
					if ((x = fread(ret, 1, len, in)) < len)
					{
						*(ret + x + 1) = 0;
						start = true;
					}
				}*/
			}
			else if (!chunked)
				start = true;
		}
		else if (start)
		{
			if (ret == NULL)
			{
				ret = (char *)malloc(strlen(read) + 1);
				*ret = '\0';
			}
			else
				ret = (char *)realloc(ret, strlen(ret) + strlen(read) + 1);

			strcat(ret, read);
		}
	}

	return ret;
}

/* Split CSV data into a multi-dimensional array
 * Returns char*** and sets rows/cols */
void ***parse_csv(char *block, long *rows, long *cols)
{
	char *line, *row, *col, *ptr;
	void ***ret;
	long x, y;

	ptr = (char *)malloc(strlen(block) + 1);
	strcpy(ptr, block);
	*cols = *rows = 1;

	col = line = strsep(&ptr, "\r\n");
	while (*col != '\0')
		*cols += (*col++ == ',');

	if (*cols < 6)
	{
		fprintf(stderr, "Error: Not enough columns!\n");
		free(block);
		free(ptr);
		return NULL;
	}

	do
	{
		if ((isdigit(*line)) && (strchr(line, ',')))
			(*rows)++;
	} while (line = strsep(&ptr, "\r\n"));
	free(ptr);

	ret = (void ***)malloc((*rows + 1) * sizeof(char *));
	for (x = 1; x <= *rows; x++)
	{
		ret[x] = (void **)malloc((*cols + 1) * sizeof(char *));
		ret[x][0] = NULL;
	}
	
	x = 0;
	ret[x] = (void **)block;
	while (line = strsep(&block, "\r\n"))
	{
		if ((!isdigit(*line)) || (!strchr(line, ',')))
			continue;

		ptr = (char *)malloc(strlen(line) + 1);
		strcpy(ptr, line);
		ret[++x][0] = ptr;

		for (y = 1; y <= *cols; y++)
			ret[x][y] = strsep(&ptr, ",");
	}

	return ret;
}

/* Recursively free data variables (one multi-dimensional array) */
void recursive_free(void ***data, long rows)
{
	long x, y;

	for (x = 1; x <= rows; x++)
	{
		if (data[x][0])
			free(data[x][0]);
		free(data[x]);
	}
	free(data[0]);
	free(data);

	return;
}

/****************************************************
 * 1.3 - Run modes
 ****************************************************
 * Call load_ticker() for each stock locally cached */
void update_tickers()
{
	struct dirent *file;
	DIR *saved;
	char *tmp;

	if (!save_config)
		return;

	if ((saved = opendir(config_dir)) == NULL)
	{
		fprintf(stderr, "Error opening %s: %s\n", config_dir, strerror(errno));
		return;
	}

	while (file = readdir(saved))
	{
		if (*(file->d_name) == '.')
			continue;

		tmp = file->d_name;
		while ((*tmp != '\0') && (*tmp != '.'))
			*tmp++ = toupper(*tmp);
		*tmp = 0;

		load_ticker(file->d_name);
	}

	closedir(saved);

	return;
}

/* Load ticker data (file, then internet) and parse */
void load_ticker(char *ticker)
{
	long x, len, rows, cols, w_rows, w_cols, vol;
	char *tmp, *block, *blocknew;
	void ***data, ***weekly;
	double rsi, weekly_rsi;
	time_t from;
	
	if ((block = load_from_file(ticker)) == NULL)
		if ((block = download_eod_data(ticker, 0)) == NULL)
			return;

	len = strlen(block);
	data = parse_csv(block, (long *)&rows, (long *)&cols);

	if ((from = get_last_date(data, rows)) != 0)
	{
		if ((blocknew = download_eod_data(ticker, from)) == NULL)
			return;

		for (x = 0; x < len; x++)
			if (*(block + x) == '\0') *(block + x) = '\n';

		tmp = (char *)malloc(strlen(block) + strlen(blocknew) + 2);
		sprintf(tmp, "%s\n%s", blocknew, block);

		free(blocknew);
		recursive_free(data, rows);

		data = parse_csv(tmp, (long *)&rows, (long *)&cols);
	}

	if (!intraday)
		save_to_file(ticker, data, rows, cols);

	vol = average_volume(data, rows);
	if (vol > 1000000)
	{
		weekly = make_weekly(data, rows, &w_rows, &w_cols);

		rsi = generate_rsi(data, rows, 14);
		weekly_rsi = generate_rsi(weekly, w_rows, 14);
		print_analysis(ticker, rsi, weekly_rsi);

		for (x = 1; x <= w_rows; x++)
			free(weekly[x]);
		free(weekly);
	}

	recursive_free(data, rows);

	return;
}

/* Print stocks that have gone up more than one percent */
void up_percent(char *percent)
{
	int amount = atoi(percent);
	char *tmp, *block;
	struct dirent *file;
	long rows, cols;
	void ***data;
	double x, y;
	DIR *saved;

	if (!save_config)
		return;

	if (amount < 1)
	{
		fprintf(stderr, "Error: Percent is less than 1\n");
		return;
	}

	if (!save_config)
		return;

	if ((saved = opendir(config_dir)) == NULL)
	{
		fprintf(stderr, "Error opening %s: %s\n", config_dir, strerror(errno));
		return;
	}

	while (file = readdir(saved))
	{
		if (*(file->d_name) == '.')
			continue;

		tmp = file->d_name;
		while ((*tmp != '\0') && (*tmp != '.'))
			*tmp++ = toupper(*tmp);
		*tmp = 0;

		if ((block = load_from_file(file->d_name)) == NULL)
			continue;

		data = parse_csv(block, (long *)&rows, (long *)&cols);

		if (rows >= 2)
		{
			x = strtod(data[2][5], NULL);
			x = (strtod(data[1][5], NULL) - x) / x * 100;
			if (x >= amount)
				printf("%+.2f: %s\n", x, file->d_name);
		}

		recursive_free(data, rows);
	}

	closedir(saved);

	return;
}

/*****************************************************
 * 1.4 - Functions which extrapolate from data
 *****************************************************
 * Get the last date we have data for, skip weekends */
time_t get_last_date(void ***data, long rows)
{
	struct tm last, now;
	time_t tmp, ret = 0;

	last.tm_hour = 0;
	last.tm_min = 0;
	last.tm_sec = 1;
	last.tm_isdst = -1;
	if (rows >= 1)
		if (!strptime(data[1][1], "%Y-%m-%d", &last))
			if (!strptime(data[1][1], "%d-%B-%y", &last))
				return 0;

	if ((tmp = mktime(&last)) == -1)
		return 0;

	ret = tmp;
	tmp += 86400;
	memcpy(&last, localtime(&tmp), sizeof(struct tm));
	if ((last.tm_wday == 0) || (last.tm_wday == 6))
	{
		ret = tmp;
		tmp += 86400;
		memcpy(&last, localtime(&tmp), sizeof(struct tm));
		if ((last.tm_wday == 0) || (last.tm_wday == 6))
			ret = tmp;
	}

	time(&tmp);
	if (ret > tmp)
		ret = 0;

	struct tm *date_start, date_finish;
	time_t epoch;

	time(&epoch);
	memcpy(&date_finish, localtime(&epoch), sizeof(struct tm));
	epoch = ((from == 0) ? epoch - 31536000 : from + 86400);
	date_start = localtime(&epoch);

	intraday = false;
	if ((date_start->tm_mday == date_finish.tm_mday) && (date_start->tm_mon  == date_finish.tm_mon) && (date_start->tm_year == date_finish.tm_year))
		intraday = true;

	return ret;
}

/* Average the stocks volume from the last two weeks */
long average_volume(void ***data, long rows)
{
	int x, days;
	long ret = 0;

	days = (10 > rows) ? rows : 10;
	for (x = 1; x <= days; x++)
		ret += strtod(data[x][6], NULL);

	ret /= days;

	return ret;
}

/* Loop through data and create an RSI value */
double generate_rsi(void ***data, long rows, int n)
{
	double ret, change, ag, al, up, down, gains = 0, losses = 0;
	double prev_gain, prev_loss, rs, rsi, *values;
	int row, start;

	if (rows <= n)
		return;

	start = (2 * n < rows - 1) ? 2 * n : rows - 1;
	values = (double *)malloc((start + 1) * sizeof(double));
	for (row = start; row >= 1; row--)
		values[row] = strtod(data[row][5], NULL);
	
	for (row = start - 1; row >= 1; row--)
	{
		change = values[row] - values[row + 1];
		if (change < 0)
		{
			down = -change;
			losses += down;
			up = 0;
		}
		else
		{
			up = change;
			gains += up;
			down = 0;
		}

		if (row < start - n)
		{
			ag = (prev_gain * (n - 1) + up) / n;
			al = (prev_loss * (n - 1) + down) / n;
		}
		else
		{
			ag = gains / n;
			al = losses / n;
		}

		rs = ag / al;
		rsi = 100 - (100 / (1 + rs));

		if (row <= start - n)
		{
			change = values[row + n - 1] - values[row + n];
			if (change < 0)
				losses += change;
			else
				gains -= change;
		}

		prev_gain = ag;
		prev_loss = al;
	}

	ret = rsi;

	free(values);

	return ret;
}

/* Convert end-of-day data to weekly data */
void ***make_weekly(void ***data, long rows, long *w_rows, long *w_cols)
{
	long x, y, volume;
	struct tm last;
	int dow, wday;
	void ***ret, *high;
	time_t tmp;

	if (rows < 1)
		return NULL;

	*w_rows = 0;
	*w_cols = 5;
	ret = (void ***)malloc((rows + 1) * sizeof(char *));
	for (x = 1; x <= rows; x++)
		ret[x] = (void **)malloc((*w_cols + 1) * sizeof(char *));

	for (x = 1; x < rows; x++)
	{
		last.tm_hour = 0;
		last.tm_min = 0;
		last.tm_sec = 1;
		last.tm_isdst = -1;
		if (!strptime(data[x][1], "%Y-%m-%d", &last))
			if (!strptime(data[x][1], "%d-%B-%y", &last))
				continue;

		if ((tmp = mktime(&last)) == -1)
			continue;

		memcpy(&last, localtime(&tmp), sizeof(struct tm));
		if (last.tm_wday > wday)
		{
			if (*w_rows > 0)
				ret[*w_rows][*w_cols] = high;

			(*w_rows)++;
			for (y = 1; y < *w_cols; y++)
				ret[*w_rows][y] = data[x][y];
			high = data[x][y];
		}
		else
		{
			if (strtol(high, NULL, 10) < strtol(data[x][*w_cols], NULL, 10))
				high = data[x][*w_cols];
			if (strtol(ret[*w_rows][3], NULL, 10) < strtol(data[x][3], NULL, 10))
				ret[*w_rows][3] = data[x][3];
			if (strtol(ret[*w_rows][4], NULL, 10) > strtol(data[x][4], NULL, 10))
				ret[*w_rows][4] = data[x][4];
		}


		wday = last.tm_wday;
	}

	ret = realloc(ret, (*w_rows + 1) * sizeof(char *));

	return ret;
}

/* Print our analysis of the stock */
void print_analysis(char *ticker, double rsi, double weekly)
{
	bool list = false;

	if ((rsi == 0) || (rsi == 100))
		return; /* delisted or bought out */

	if ((rsi < 30) || (rsi > 70))
		list = true;
	if ((weekly < 30) || (weekly > 70))
		list = true;

	if (!list)
		return;

	printf("%s:\n", ticker);
	if (rsi < 30)
		printf("\tDaily RSI: %03.2f < 30\n", rsi);
	else if (rsi > 70)
		printf("\tDaily RSI: %03.2f > 70\n", rsi);
	if (weekly < 30)
		printf("\tWeekly RSI: %03.2f < 30\n", weekly);
	else if (weekly > 70)
		printf("\tWeekly RSI: %03.2f > 70\n", weekly);

	return;
}
